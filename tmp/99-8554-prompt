<DIRECTIONS>
message_stream implement parseGiftStartProcess, map the data
</DIRECTIONS>
<Context>
You receive a selection in neovim that you need to replace with new code.
The selection's contents may contain notes, incorporate the notes every time if there are some.
consider the context of the selection and what you are suppose to be implementing
<SELECTION_LOCATION>
range(point(158,1),point(160,1))
</SELECTION_LOCATION>
<SELECTION_CONTENT>
func (c *WsClient) parseGiftStarProcess(body []byte) *GiftStarProcessData {
	

</SELECTION_CONTENT>
<FILE_CONTAINING_SELECTION>
package live

import (
	"encoding/json"
	"log"
	"time"
)

func (c *WsClient) routeOperation(header *Header, body []byte) {
	switch header.Operation {
	case OpHeartbeatReply:
		// Heartbeat Reply no longer contains popularity data

	case OpSendMsgReply:
		c.dispatch(body)

	case OpAuthReply:
		c.eventCh <- Event{
			Type:      SysMsgEvent,
			Data:      "连接上了...",
			Timestamp: time.Now().UnixNano(),
		}

	default:
		log.Printf("[Yuuna-Danmu] Unknown operation: %d", header.Operation)
	}
}

func (c *WsClient) dispatch(body []byte) {
	var base BaseMsg
	if err := json.Unmarshal(body, &base); err != nil {
		return
	}

	switch base.Cmd {
	case DanmuEvent:
		data := c.parseDanmu(body)
		c.eventCh <- Event{
			Type:      DanmuEvent,
			Data:      data,
			Timestamp: time.Now().UnixNano(),
		}
	case GiftEvent:
		data := c.parseGift(body)
		c.eventCh <- Event{
			Type:      GiftEvent,
			Data:      data,
			Timestamp: time.Now().UnixNano(),
		}
	case SuperChatEvent:
		data := c.parseSuperChat(body)
		c.eventCh <- Event{
			Type:      SuperChatEvent,
			Data:      data,
			Timestamp: time.Now().UnixNano(),
		}
	case InteractionEvent:
		data := c.parseInteraction(body)
		log.Println(data)
		c.eventCh <- Event{
			Type:      InteractionEvent,
			Data:      data,
			Timestamp: time.Now().UnixNano(),
		}
	case UserToastEvent:
		data := c.parseToast(body)
		c.eventCh <- Event{
			Type:      UserToastEvent,
			Data:      data,
			Timestamp: time.Now().UnixNano(),
		}
	case GiftStarProcessEvent:
		data := c.parseGiftStarProcess(body)
		c.eventCh <- Event{
			Type:      GiftStarProcessEvent,
			Data:      data,
			Timestamp: time.Now().UnixNano(),
		}
	default:
	}
}

func (c *WsClient) parseInteraction(body []byte) *InteractMsg {
	var raw struct {
		Data InteractMsg `json:"data"`
	}
	if err := json.Unmarshal(body, &raw); err != nil {
		return nil
	}
	return &raw.Data
}

func (c *WsClient) parseToast(body []byte) *ToastMsgData {
	var raw struct {
		Data ToastMsgData `json:"data"`
	}
	if err := json.Unmarshal(body, &raw); err != nil {
		return nil
	}
	return &raw.Data
}

func (c *WsClient) parseDanmu(body []byte) *DanmuMsg {
	var raw struct {
		Info []interface{} `json:"info"`
	}
	if err := json.Unmarshal(body, &raw); err != nil {
		return nil
	}

	if len(raw.Info) < 3 {
		return nil
	}

	content, _ := raw.Info[1].(string)

	userSlice, _ := raw.Info[2].([]interface{})
	nickname, _ := userSlice[1].(string)

	var medalName string
	var medalLevel int
	if medalSlice, ok := raw.Info[3].([]interface{}); ok && len(medalSlice) > 0 {
		medalLevel = int(medalSlice[0].(float64))
		medalName, _ = medalSlice[1].(string)
	}
	danMu := &DanmuMsg{
		Content:    content,
		UserID:     int64(userSlice[0].(float64)),
		Nickname:   nickname,
		MedalName:  medalName,
		MedalLevel: medalLevel,
	}

	return danMu
}

func (c *WsClient) parseGift(body []byte) *GiftData {
	var raw struct {
		Data GiftData `json:"data"`
	}

	if err := json.Unmarshal(body, &raw); err != nil {
		return nil
	}
	return &raw.Data
}

func (c *WsClient) parseSuperChat(body []byte) *SuperChatMsgData {
	var raw struct {
		Data SuperChatMsgData `json:"data"`
	}
	if err := json.Unmarshal(body, &raw); err != nil {
		return nil
	}
	return &raw.Data
}

func (c *WsClient) parseGiftStarProcess(body []byte) *GiftStarProcessData {
	
}
</FILE_CONTAINING_SELECTION>

</Context>

## Style Guide

* **Style:** Rose-Pine as the base style for GUI.

## Project Structure

```text
├── build/             # Binary build artifacts
├── doc/               # Protocol documentation (message_stream.md)
|--- api/
|   ├── grpc/          # gRPC service definitions and generated code
├── pkg/
│   ├── app/           # Core logic and Mock implementations
│   └── remote/        # Bilibili API connection handling
├── frontend/          # Svelte source code
└── main.go            # Entry point

```

## Code Standards

* **Safety First:** Handle all pointer references and nil-checks, especially during JSON/Protobuf unmarshaling.
* **Readability:** Use clear naming conventions that reflect the Bilibili API terminology.
* **Scalability:** Keep the message parsing logic decoupled from the UI/gRPC dispatching logic.

<MustObey>
NEVER alter any file other than TEMP_FILE.
never provide the requested changes as conversational output. Return only the code.
ONLY provide requested changes by writing the change to TEMP_FILE

never attempt to read TEMP_FILE.  It is purely for output.  Previous contents, which may not exist, can be written over without worry
</MustObey>
<TEMP_FILE>/Users/barry/workspace/github/yuuna-danmu/tmp/99-8554</TEMP_FILE>