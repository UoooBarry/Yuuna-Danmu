<DIRECTIONS>
udpate the system message from Chinese to English
</DIRECTIONS>
<Context>
You receive a selection in neovim that you need to replace with new code.
The selection's contents may contain notes, incorporate the notes every time if there are some.
consider the context of the selection and what you are suppose to be implementing
<SELECTION_LOCATION>
range(point(144,1),point(152,1))
</SELECTION_LOCATION>
<SELECTION_CONTENT>
func (w *WailsUI) SaveConfig(payload ConfigPayload) {
	if w.onConfigChange != nil {
		err := w.onConfigChange(payload)
		if err != nil {
			w.AppendError(err)
		}
	}
	w.AppendSysMsg("‰øùÂ≠òÊàêÂäü")

</SELECTION_CONTENT>
<FILE_CONTAINING_SELECTION>
package ui

import (
	"context"
	"fmt"
	"time"

	"uooobarry/yuuna-danmu/pkg/config"
	"uooobarry/yuuna-danmu/pkg/live"

	"github.com/wailsapp/wails/v2"
	"github.com/wailsapp/wails/v2/pkg/options"
	"github.com/wailsapp/wails/v2/pkg/options/assetserver"
	"github.com/wailsapp/wails/v2/pkg/options/mac"
	"github.com/wailsapp/wails/v2/pkg/options/windows"
	"github.com/wailsapp/wails/v2/pkg/runtime"
)

type WailsUI struct {
	ctx            context.Context
	onConfigChange OnConfigChange
	emitter        func(ctx context.Context, name string, data ...any)
	assetOpts      *assetserver.Options
}

type OnConfigChange func(payload ConfigPayload) error

func NewWailsUI(assetOts *assetserver.Options, opts ...func(*WailsUI)) *WailsUI {
	ui := &WailsUI{
		assetOpts: assetOts,
		emitter:   runtime.EventsEmit,
	}
	return ui
}

func (w *WailsUI) Stop() {
	if w.ctx != nil {
		runtime.Quit(w.ctx)
	}
}

func (w *WailsUI) SetContext(ctx context.Context) {
	w.ctx = ctx
}

func (w *WailsUI) OnStartup(ctx context.Context) {
	w.ctx = ctx
}

func (w *WailsUI) SetOnConfigChange(onConfigChange OnConfigChange) {
	w.onConfigChange = onConfigChange
}

func (w *WailsUI) Start() error {
	return wails.Run(&options.App{
		Title:            "Yuuna Danmu",
		Width:            384,
		Height:           624,
		Frameless:        true,
		AlwaysOnTop:      true,
		BackgroundColour: &options.RGBA{R: 0, G: 0, B: 0, A: 0},
		AssetServer:      w.assetOpts,
		Windows: &windows.Options{
			WebviewIsTransparent: true,
			WindowIsTranslucent:  true,
			BackdropType:         windows.Mica,
		},
		OnStartup: w.OnStartup,
		Bind: []interface{}{
			w,
		},
		Mac: &mac.Options{
			WebviewIsTransparent: true,
			WindowIsTranslucent:  true,
			About: &mac.AboutInfo{
				Title: "Yuuna Danmu",
			},
		},
	})
}

func (w *WailsUI) AppendDanmu(medalName string, medalLevel int, nickname, content string) {
	if w.ctx == nil {
		return
	}

	w.emitter(w.ctx, live.DanmuEvent, map[string]string{
		"nickname":   nickname,
		"content":    content,
		"medalName":  medalName,
		"medalLevel": fmt.Sprintf("%d", medalLevel),
		"timestamp":  time.Now().Format(time.TimeOnly),
	})
}

func (w *WailsUI) AppendGift(gift *live.GiftData) {
	if w.ctx == nil {
		return
	}

	w.emitter(w.ctx, live.GiftEvent, gift)
}

func (w *WailsUI) AppendSuperChat(superchat *live.SuperChatMsgData) {
	if w.ctx == nil {
		return
	}

	w.emitter(w.ctx, live.SuperChatEvent, superchat)
}

func (w *WailsUI) AppendInteraction(interaction *live.InteractMsg) {
	if w.ctx == nil {
		return
	}

	w.emitter(w.ctx, live.InteractionEvent, interaction)
}

func (w *WailsUI) UpdatePopularity(popularity int) {
	if w.ctx == nil {
		return
	}

	w.emitter(w.ctx, live.PopularityEvent, popularity)
}

func (w *WailsUI) AppendError(err error) {
	if w.ctx == nil {
		return
	}

	w.emitter(w.ctx, live.ErrorEvent, err.Error())
}

func (w *WailsUI) AppendSysMsg(msg string) {
	if w.ctx == nil {
		return
	}

	w.emitter(w.ctx, live.SysMsgEvent, msg)
}

func (w *WailsUI) SaveConfig(payload ConfigPayload) {
	if w.onConfigChange != nil {
		err := w.onConfigChange(payload)
		if err != nil {
			w.AppendError(err)
		}
	}
	w.AppendSysMsg("‰øùÂ≠òÊàêÂäü")
}

func (w *WailsUI) LoadConfig() *config.AppConfig {
	return config.Load()
}

func (w *WailsUI) AppendGiftStarProcess(data *live.GiftStarProcessData) {
	if w.ctx == nil {
		return
	}

	w.emitter(w.ctx, live.GiftStarProcessEvent, data)
}
</FILE_CONTAINING_SELECTION>

</Context>

# BiliLive-Bridge: High-Performance gRPC Broadcast Gateway

A robust, cross-platform desktop application designed to interface with Bilibili Live rooms in real-time. This project bridges Bilibili's message stream with external services via gRPC, allowing developers to build complex live-stream interactions (like AI VTubers, interactive games, or data dashboards) with ease.

## üöÄ Tech Stack

* **Backend:** [Go](https://go.dev/) (High-performance concurrency)
* **Frontend:** [Svelte](https://svelte.dev/) + [Tailwind CSS](https://tailwindcss.com/) (Reactive UI), also support Terminal version if switch in `main.go`
* **Bridge Layer:** [Wails v2](https://wails.io/) (Native OS integration)
* **Communication:** [gRPC](https://grpc.io/) & Protobuf (Type-safe external API)
* **Style:** Rose-Pine as the base style for GUI.

## ‚ú® Core Features

* **Real-time Streaming:** Seamlessly capture Danmaku (comments), Gifts, Guard (Captain) subscriptions, and more.
* **Extensible Architecture:** Out-of-the-box **gRPC** support to push live data to other microservices or local applications.
* **Developer Friendly:** Clean, modular code designed for scalability and readability.
* **Mock Environment:** Includes a built-in mock server for local testing without needing an active internet connection or live room.

---

## üõ† Project Structure

```text
‚îú‚îÄ‚îÄ build/             # Binary build artifacts
‚îú‚îÄ‚îÄ doc/               # Protocol documentation (message_stream.md)
|--- api/
|   ‚îú‚îÄ‚îÄ grpc/          # gRPC service definitions and generated code
‚îú‚îÄ‚îÄ pkg/
‚îÇ   ‚îú‚îÄ‚îÄ app/           # Core logic and Mock implementations
‚îÇ   ‚îî‚îÄ‚îÄ remote/        # Bilibili API connection handling
‚îú‚îÄ‚îÄ frontend/          # Svelte source code
‚îî‚îÄ‚îÄ main.go            # Entry point

```

## üìñ Development Guidelines

### 1. Protocol Documentation

Before making changes to message handling, **must** read:
`doc/message_stream.md`
This document tracks the current state of Bilibili's live protocol and our internal mapping.

### 2. Implementing New Events

When adding new Danmaku event types:

1. **Define the struct** in the relevant message package.
2. **Update the Mock Server:** You must update `pkg/app/mock.go` to include the new event. This ensures real-time UI testing and gRPC downstream verification work without a live connection.
3. **Update Protobuf:** If the event needs to be exposed via gRPC, update the `.proto` files and regenerate the code.

### 3. Code Standards

* **Safety First:** Handle all pointer references and nil-checks, especially during JSON/Protobuf unmarshaling.
* **Readability:** Use clear naming conventions that reflect the Bilibili API terminology.
* **Scalability:** Keep the message parsing logic decoupled from the UI/gRPC dispatching logic.

---

## üèó Getting Started

**Prerequisites:**

* Go 1.20+
* Node.js & NPM
* Wails CLI

**Installation:**

```bash
# Install Wails if you haven't
go install github.com/wailsapp/wails/v2/cmd/wails@latest

# Run in development mode
wails dev

```

## üìú License

[MIT License](https://www.google.com/search?q=LICENSE)

<MustObey>
NEVER alter any file other than TEMP_FILE.
never provide the requested changes as conversational output. Return only the code.
ONLY provide requested changes by writing the change to TEMP_FILE

never attempt to read TEMP_FILE.  It is purely for output.  Previous contents, which may not exist, can be written over without worry
</MustObey>
<TEMP_FILE>/Users/barry/workspace/github/yuuna-danmu/tmp/99-217</TEMP_FILE>